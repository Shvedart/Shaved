<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SVG Morph — mouse controlled</title>
  <style>
    /* Полноэкранный холст, тёмный фон, без прокрутки */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #000;
      color: #ddd;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
      user-select: none;
      overflow: hidden;
    }
    .wrap {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
    }
    /* Контейнер для видимого SVG */
    #stage {
      width: min(100vw, 177.78vh); /* 16:9 вписывание */
      height: auto;
      display: block;
    }
    /* Подсказка */
    .hint {
      position: fixed;
      left: 12px;
      bottom: 10px;
      font-size: 12px;
      color: #9aa3ad;
      opacity: 0.75;
      pointer-events: none;
      white-space: pre-line;
    }
    .error {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      color: #ffb4b4;
      font-size: 14px;
      text-align: center;
      padding: 16px;
    }
  </style>
</head>
<body>
  <div class="wrap" id="wrap">
    <!-- Сюда будет добавлен клон из первого SVG -->
  </div>
  <script>
    // Настройки — имена SVG в текущей папке
    const SVG_A_URL = 'switch-iframe_sid_1184_43444.svg'; // левое положение
    const SVG_B_URL = 'switch-iframe_sid_1184_43496.svg'; // правое положение

    // Регекс для чисел в атрибутах путей (поддержка -, . и экспоненты)
    const NUMBER_RE = /-?\d*\.?\d+(?:e[-+]?\d+)?/gi;

    /**
     * Извлекает "части" (литеральные фрагменты) и последовательность чисел из атрибута 'd'.
     * Пример: "M10 20L30,40" -> parts: ["M", " ", "L", ",", ""], numbers: [10, 20, 30, 40]
     */
    function tokenizeD(d) {
      const parts = d.split(NUMBER_RE);
      const nums = (d.match(NUMBER_RE) || []).map(Number);
      return { parts, nums };
    }

    /**
     * Сборка строки 'd' по шаблону parts и массиву чисел nums.
     * Для стабильности округляем до 3 знаков после запятой.
     */
    function buildD(parts, nums) {
      const n = Math.min(parts.length - 1, nums.length);
      let out = parts[0] ?? '';
      for (let i = 0; i < n; i++) {
        const v = nums[i];
        // Форматирование без лишних нулей
        const s = Number.isFinite(v) ? (Math.round(v * 1000) / 1000).toString() : '0';
        out += s + (parts[i + 1] ?? '');
      }
      // Если parts длиннее, добавим хвост (как правило пусто)
      for (let i = n + 1; i < parts.length; i++) {
        out += parts[i] ?? '';
      }
      return out;
    }

    /** Линейная интерполяция чисел массива A -> B по t в [0..1] */
    function lerpArrays(a, b, t, out) {
      const n = Math.min(a.length, b.length);
      for (let i = 0; i < n; i++) {
        out[i] = a[i] + (b[i] - a[i]) * t;
      }
      return out;
    }
    // Easing-функция для интро: плавное ускорение/замедление (ease-in-out cubic)
    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    /**
     * Строит интерполяторы для всех путей (path) между двумя SVG.
     * Возвращает:
     *  - root: видимый SVG (клон из A), уже вставленный в DOM
     *  - items: массив элементов с данными для морфинга
     */
    function prepareInterps(svgA, svgB) {
      // Клонируем A как базу отображения
      const root = svgA.cloneNode(true);
      // Синхронизируем ключевые атрибуты корня на всякий случай
      for (const attr of ['viewBox', 'width', 'height']) {
        const v = svgA.getAttribute(attr);
        if (v != null) root.setAttribute(attr, v);
      }
      root.id = 'stage';
      // Списки путей
      const pathsA = svgA.querySelectorAll('path');
      const pathsB = svgB.querySelectorAll('path');
      const pathsR = root.querySelectorAll('path');
      const count = Math.min(pathsA.length, pathsB.length, pathsR.length);
      const items = [];

      for (let i = 0; i < count; i++) {
        const a = pathsA[i];
        const b = pathsB[i];
        const r = pathsR[i];
        const dA = a.getAttribute('d') || '';
        const dB = b.getAttribute('d') || '';
        if (!dA || !dB) continue;
        const tokA = tokenizeD(dA);
        const tokB = tokenizeD(dB);
        const n = Math.min(tokA.nums.length, tokB.nums.length);
        // Предвыделяем буфер для интерполяции
        const buf = new Array(n).fill(0);
        // Шаблон фиксируем от A (ожидается одинаковая структура)
        items.push({
          el: r,
          parts: tokA.parts,
          aNums: tokA.nums.slice(0, n),
          bNums: tokB.nums.slice(0, n),
          buf
        });
      }
      return { root, items };
    }

    /** Применение t ко всем путям */
    function applyT(items, t) {
      for (let i = 0; i < items.length; i++) {
        const it = items[i];
        const nums = lerpArrays(it.aNums, it.bNums, t, it.buf);
        const d = buildD(it.parts, nums);
        it.el.setAttribute('d', d);
      }
    }

    /** Основная логика */
    (async function main() {
      const wrap = document.getElementById('wrap');
      try {
        // Загружаем оба SVG
        const [aText, bText] = await Promise.all([
          fetch(SVG_A_URL).then(r => {
            if (!r.ok) throw new Error('Не удалось загрузить ' + SVG_A_URL);
            return r.text();
          }),
          fetch(SVG_B_URL).then(r => {
            if (!r.ok) throw new Error('Не удалось загрузить ' + SVG_B_URL);
            return r.text();
          })
        ]);
        // Парсим как SVG XML
        const parser = new DOMParser();
        const docA = parser.parseFromString(aText, 'image/svg+xml');
        const docB = parser.parseFromString(bText, 'image/svg+xml');
        const svgA = docA.documentElement;
        const svgB = docB.documentElement;
        if (svgA.nodeName.toLowerCase() !== 'svg' || svgB.nodeName.toLowerCase() !== 'svg') {
          throw new Error('Файлы не являются валидными SVG.');
        }

        // Готовим интерполяторы
        const { root, items } = prepareInterps(svgA, svgB);
        wrap.innerHTML = '';
        wrap.appendChild(root);

        // Управление t положением мыши
        let targetT = 0;
        let currentT = 0;
        let rafId = 0;
        // Интро-анимация: первые 2 секунды автоматически слева направо
        const INTRO_DURATION_MS = 2000;
        let isIntro = true;
        let introStart = performance.now();

        function onMove(clientX) {
          if (isIntro) return; // во время интро игнорируем движения
          const w = window.innerWidth || 1;
          targetT = Math.min(1, Math.max(0, clientX / w));
          // старт анимации
          if (!rafId) rafId = requestAnimationFrame(tick);
        }

        // Небольшое сглаживание, чтобы было плавнее
        function tick() {
          // Во время интро двигаем напрямую от 0 к 1 за 2 секунды
          if (isIntro) {
            const elapsed = performance.now() - introStart;
            const p = Math.min(1, elapsed / INTRO_DURATION_MS);
            currentT = easeInOutCubic(p);
            applyT(items, currentT);
            if (p < 1) {
              rafId = requestAnimationFrame(tick);
            } else {
              isIntro = false;
              targetT = currentT; // зафиксируем конечное значение
              rafId = 0;
            }
            return;
          }
          const speed = 0.25; // чем больше, тем быстрее догоняет
          const dt = targetT - currentT;
          if (Math.abs(dt) < 0.001) {
            currentT = targetT;
            applyT(items, currentT);
            rafId = 0;
            return;
          }
          currentT += dt * speed;
          applyT(items, currentT);
          rafId = requestAnimationFrame(tick);
        }

        // Слушатели: мышь и тач/пойнтер
        window.addEventListener('mousemove', (e) => onMove(e.clientX), { passive: true });
        window.addEventListener('pointermove', (e) => onMove(e.clientX), { passive: true });
        window.addEventListener('touchmove', (e) => {
          if (e.touches && e.touches.length) onMove(e.touches[0].clientX);
        }, { passive: true });

        // Начальное применение (слева = состояние A)
        applyT(items, 0);
        // Запуск интро-анимации
        if (!rafId) rafId = requestAnimationFrame(tick);
      } catch (err) {
        console.error(err);
        const div = document.createElement('div');
        div.className = 'error';
        div.textContent = 'Ошибка загрузки или обработки SVG:\n' + (err && err.message ? err.message : err);
        wrap.replaceChildren(div);
      }
    })();
  </script>
</body>
<!--
  Как это работает:
  - Внутри JS загружаются оба SVG (левое и правое состояния).
  - Для каждой пары <path> извлекаются численные координаты из атрибута "d".
  - При движении мыши вычисляется t от 0 (лево) до 1 (право) и все числа плавно интерполируются.
  - Визуально это даёт морфинг: координаты точек переходят из состояния A в состояние B.
  Требование "весь CSS и JS внутри" соблюдено: стили и скрипты в этом же HTML.
  SVG-файлы используются как источники состояний (их содержимое не дублируется внутрь HTML).
-->
</html>

